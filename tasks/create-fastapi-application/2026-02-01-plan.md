---
task: create-fastapi-application
type: plan
repo: analytics
branch: main
sha: no-commits-yet
---

# FastAPI Skeleton Application Implementation Plan

## Overview

Create a skeleton FastAPI application with a factory pattern, async lifespan context manager, and versioned health/readiness endpoints. This establishes the foundational application structure that future features will build upon, following patterns documented in ARCHITECTURE.md.

## Current State Analysis

The project has minimal implementation - only a placeholder `main()` function exists:

**File**: `src/commerce_intelligence/__init__.py:1-2`
```python
def main() -> None:
    print("Hello from commerce-intelligence!")
```

All required dependencies are installed (`fastapi[standard]`, `pydantic`, `pydantic-settings`, `uvicorn`) but not utilized.

### Key Discoveries:
- Entry point `commerce-intelligence` maps to `commerce_intelligence:main` (`pyproject.toml:17-18`)
- Architecture patterns documented in `ARCHITECTURE.md:759-799` but not implemented
- No routers, configuration, or application factory exists
- Python 3.11+ required (`pyproject.toml:9`)

## Desired End State

A working FastAPI application with:
- `commerce-intelligence` CLI command starts the server
- Application factory pattern (`create_app()`) in separate `main.py` module
- Async lifespan context manager for lifecycle management
- `/api/v1/health` returning `{"status": "healthy"}`
- `/api/v1/readiness` returning `{"status": "ready", "checks": {}}`
- Configuration via pydantic-settings with environment variable support
- Uvicorn with reload capability controlled by `debug` setting

**Verification**:
```bash
commerce-intelligence  # Starts server on http://0.0.0.0:8000
curl http://localhost:8000/api/v1/health  # Returns {"status":"healthy"}
curl http://localhost:8000/api/v1/readiness  # Returns {"status":"ready","checks":{}}
curl http://localhost:8000/docs  # OpenAPI documentation available
```

## What We're NOT Doing

- Database connections or BigQuery client setup
- Analytics service layer, query building, or business logic
- Authentication or authorization
- Full router structure for orders/customers/revenue
- Caching layer
- Production deployment configuration (Docker, etc.)
- Creating empty placeholder directories for future features
- Tests (will be added in a separate task)

## Implementation Approach

Build incrementally in three phases, each independently verifiable:
1. **Configuration** - Establish settings foundation with pydantic-settings
2. **Health Router** - Create versioned endpoints for operational monitoring
3. **Application Factory** - Wire everything together with lifespan and entry point

---

## Phase 1: Configuration Module

### Overview
Create the core configuration using pydantic-settings. This establishes the foundation that all other components depend on.

### Changes Required:

#### 1.1 Core Package Init

**File**: `src/commerce_intelligence/core/__init__.py`
**Changes**: Create new empty `__init__.py` to establish core package

```python
"""Core configuration and utilities for Commerce Intelligence API."""
```

#### 1.2 Settings Configuration

**File**: `src/commerce_intelligence/core/config.py`
**Changes**: Create new file with Settings class and cached factory function

```python
"""Application configuration using pydantic-settings."""

from functools import lru_cache

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """Application settings loaded from environment variables."""

    api_title: str = "Commerce Intelligence API"
    api_version: str = "0.1.0"
    host: str = "0.0.0.0"
    port: int = 8000
    debug: bool = False

    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"


@lru_cache
def get_settings() -> Settings:
    """Get cached settings instance."""
    return Settings()
```

### Success Criteria:

#### Automated Verification:
- [ ] Settings module imports without error: `python -c "from commerce_intelligence.core.config import get_settings; print(get_settings())"`
- [ ] Type checking passes: `pyrefly check src/commerce_intelligence/core/`
- [ ] Linting passes: `ruff check src/commerce_intelligence/core/`

---

## Phase 2: Health Router

### Overview
Create the health and readiness endpoints as a versioned router. These endpoints support container orchestration (Kubernetes liveness/readiness probes).

### Changes Required:

#### 2.1 API Package Init

**File**: `src/commerce_intelligence/api/__init__.py`
**Changes**: Create new empty `__init__.py` to establish api package

```python
"""API layer for Commerce Intelligence."""
```

#### 2.2 Routers Package Init

**File**: `src/commerce_intelligence/api/routers/__init__.py`
**Changes**: Create new empty `__init__.py` to establish routers package

```python
"""API routers."""
```

#### 2.3 Health Router

**File**: `src/commerce_intelligence/api/routers/health.py`
**Changes**: Create new file with health and readiness endpoints

```python
"""Health and readiness endpoints for operational monitoring."""

from typing import Any

from fastapi import APIRouter

router = APIRouter(tags=["health"])


@router.get("/health")
async def health() -> dict[str, str]:
    """Liveness probe endpoint.

    Returns basic health status indicating the application process is running.
    Used by container orchestration to determine if the process should be restarted.
    """
    return {"status": "healthy"}


@router.get("/readiness")
async def readiness() -> dict[str, Any]:
    """Readiness probe endpoint.

    Returns readiness status with dependency checks.
    Used by container orchestration to determine if traffic should be routed.

    The checks dict will be populated with dependency statuses (database, cache, etc.)
    as they are added to the application.
    """
    checks: dict[str, Any] = {}
    # Future: checks["database"] = await check_database()
    return {"status": "ready", "checks": checks}
```

### Success Criteria:

#### Automated Verification:
- [ ] Router imports without error: `python -c "from commerce_intelligence.api.routers.health import router; print([r.path for r in router.routes])"`
- [ ] Type checking passes: `pyrefly check src/commerce_intelligence/api/`
- [ ] Linting passes: `ruff check src/commerce_intelligence/api/`

---

## Phase 3: Application Factory and Entry Point

### Overview
Create the FastAPI application factory with lifespan context manager and update the entry point to run the server with Uvicorn.

### Changes Required:

#### 3.1 Application Factory

**File**: `src/commerce_intelligence/main.py`
**Changes**: Create new file with lifespan context manager and create_app() factory

```python
"""FastAPI application factory and lifespan management."""

from collections.abc import AsyncIterator
from contextlib import asynccontextmanager

from fastapi import FastAPI

from commerce_intelligence.api.routers.health import router as health_router
from commerce_intelligence.core.config import get_settings


@asynccontextmanager
async def lifespan(app: FastAPI) -> AsyncIterator[None]:
    """Application lifespan context manager.

    Handles startup and shutdown events for the application.
    Future: Initialize database connections, caches, etc. on startup.
    Future: Clean up resources on shutdown.
    """
    # Startup
    yield
    # Shutdown


def create_app() -> FastAPI:
    """Create and configure the FastAPI application.

    Returns:
        Configured FastAPI application instance.
    """
    settings = get_settings()

    app = FastAPI(
        title=settings.api_title,
        version=settings.api_version,
        lifespan=lifespan,
    )

    # Register routers
    app.include_router(health_router, prefix="/api/v1")

    return app
```

#### 3.2 Update Entry Point

**File**: `src/commerce_intelligence/__init__.py`
**Changes**: Replace placeholder with uvicorn server startup

```python
"""Commerce Intelligence API - Entry point."""


def main() -> None:
    """Run the Commerce Intelligence API server."""
    import uvicorn

    from commerce_intelligence.core.config import get_settings

    settings = get_settings()

    uvicorn.run(
        "commerce_intelligence.main:create_app",
        factory=True,
        host=settings.host,
        port=settings.port,
        reload=settings.debug,
    )
```

### Success Criteria:

#### Automated Verification:
- [ ] Application creates without error: `python -c "from commerce_intelligence.main import create_app; app = create_app(); print(app.title)"`
- [ ] Type checking passes: `pyrefly check src/commerce_intelligence/`
- [ ] Linting passes: `ruff check src/commerce_intelligence/`

#### Manual Verification:
- [ ] Run `commerce-intelligence` and verify server starts on http://0.0.0.0:8000
- [ ] Test `curl http://localhost:8000/api/v1/health` returns `{"status":"healthy"}`
- [ ] Test `curl http://localhost:8000/api/v1/readiness` returns `{"status":"ready","checks":{}}`
- [ ] Verify OpenAPI docs available at http://localhost:8000/docs
- [ ] Verify setting `DEBUG=true` enables auto-reload (modify a file, see server restart)

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding.

---
