---
date: 2026-02-01T16:37:07Z
git_commit: no-commit-yet
branch: main
repository: analytics
topic: "FastAPI Application Structure, Entry Points, and Configuration Patterns"
type: research
tags: [research, codebase, fastapi, pydantic-settings, dependency-injection, configuration]
status: complete
---

# Research: FastAPI Application Structure, Entry Points, and Configuration Patterns

**Date**: 2026-02-01T16:37:07Z
**Git Commit**: no-commit-yet (new project)
**Branch**: main
**Repository**: analytics

## Research Question

1. Explain how the project is currently structured in `src/commerce_intelligence/` and what entry points or configurations exist in `pyproject.toml` for running the application
2. Explore the ARCHITECTURE.md document to understand the intended FastAPI application structure, including directory layout, API layer organization, and configuration patterns that should be followed
3. Find any existing patterns or examples in the codebase for dependency injection, configuration management with pydantic-settings, or application factory patterns that could inform the FastAPI app creation
4. Trace how the application is expected to be started based on the `pyproject.toml` scripts configuration and any existing main module entry points

## Research Methodology (verbatim)

This document will remain objective and factual. It does not contain any recommendations or implementation suggestions.
Open questions will not ask Why things haven't been built or what should be built in the future.

There is no "implementation" section - that is intentional.

## Summary

The project is at an early stage with minimal implementation. The `src/commerce_intelligence/` directory contains only a single `__init__.py` file with a placeholder `main()` function. The `pyproject.toml` configures a script entry point `commerce-intelligence` that maps to this `main` function. All FastAPI, Pydantic, pydantic-settings, and Uvicorn dependencies are installed but not yet utilized.

The ARCHITECTURE.md document provides comprehensive documentation of the intended application structure, including a layered architecture (API → Service → Query Building → Database), dependency injection patterns using `Depends()` and `@lru_cache()`, configuration management with `pydantic-settings.BaseSettings`, and a detailed directory structure. A second document, ARCHITECTURE_REVISED.md, exists with a simplified variant that emphasizes row-level security.

No actual patterns for dependency injection, configuration management, or application factory exist in the codebase yet—all patterns are documented in the architecture files but not implemented.

## Detailed Findings

### 1. Current Project Structure in `src/commerce_intelligence/`

The source directory contains minimal implementation:

```
src/
└── commerce_intelligence/
    └── __init__.py
```

**File Contents** (`src/commerce_intelligence/__init__.py:1-2`):
```python
def main() -> None:
    print("Hello from commerce-intelligence!")
```

This is the only Python file in the project. It contains:
- A single `main()` function
- No imports
- No FastAPI application
- No configuration
- No routers, services, or database modules

### 2. Entry Points and Configuration in `pyproject.toml`

**Script Entry Point** (`pyproject.toml:17-18`):
```toml
[project.scripts]
commerce-intelligence = "commerce_intelligence:main"
```

This configures a CLI command `commerce-intelligence` that invokes the `main()` function from the `commerce_intelligence` package (located at `src/commerce_intelligence/__init__.py:1`).

**Dependencies** (`pyproject.toml:10-15`):
```toml
dependencies = [
    "fastapi[standard]>=0.128.0",
    "pydantic>=2.12.5",
    "pydantic-settings>=2.12.0",
    "uvicorn>=0.40.0",
]
```

**Project Metadata** (`pyproject.toml:1-9`):
- Name: `commerce-intelligence`
- Version: `0.1.0`
- Python requirement: `>=3.11`

**Build System** (`pyproject.toml:21-22`):
- Uses `uv_build` as build backend

### 3. Intended FastAPI Application Structure (from ARCHITECTURE.md)

The architecture document defines a layered structure (`ARCHITECTURE.md:18-84`):

```
FastAPI Layer → Service Layer → Query Building Layer → Database Abstraction Layer → Data Store
```

**Intended Directory Layout** (`ARCHITECTURE.md:697-751`):
```
src/
├── commerce_intelligence/
│   ├── __init__.py
│   ├── main.py                      # FastAPI app initialization
│   ├── api/                         # API Layer
│   │   ├── __init__.py
│   │   ├── dependencies.py          # DI container
│   │   ├── routers/
│   │   │   ├── __init__.py
│   │   │   ├── orders.py
│   │   │   ├── customers.py
│   │   │   └── revenue.py
│   │   └── models/
│   │       ├── __init__.py
│   │       ├── requests.py
│   │       └── responses.py
│   ├── services/                    # Service Layer
│   │   ├── __init__.py
│   │   └── analytics_service.py
│   ├── query/                       # Query Building Layer
│   │   ├── __init__.py
│   │   ├── builder.py
│   │   ├── definition.py
│   │   ├── filters.py
│   │   └── aggregations.py
│   ├── database/                    # Database Abstraction Layer
│   │   ├── __init__.py
│   │   ├── client.py
│   │   └── bigquery/
│   │       ├── __init__.py
│   │       ├── client.py
│   │       └── translator.py
│   └── core/
│       ├── __init__.py
│       ├── config.py
│       └── exceptions.py
├── tests/
├── pyproject.toml
└── README.md
```

### 4. Documented Dependency Injection Patterns

**Factory Function Pattern** (`ARCHITECTURE.md:783-799`):
```python
from functools import lru_cache
from app.core.config import settings

@lru_cache()
def get_database_client() -> DatabaseClient:
    """Factory for database client based on configuration."""
    if settings.database_type == "bigquery":
        return BigQueryClient(
            project_id=settings.bigquery_project_id,
            dataset_id=settings.bigquery_dataset_id
        )
    raise ValueError(f"Unsupported database type: {settings.database_type}")

def get_analytics_service(
    db_client: DatabaseClient = Depends(get_database_client)
) -> AnalyticsService:
    """Factory for analytics service."""
    return AnalyticsService(db_client=db_client)
```

**Endpoint DI Usage** (`ARCHITECTURE.md:110-120`):
```python
@router.get("/orders/analytics")
async def get_orders_analytics(
    request: AnalyticsRequest = Depends(),
    service: AnalyticsService = Depends(get_analytics_service)
):
    result = await service.execute_analytics_query(
        table="orders",
        request=request
    )
    return result
```

Key patterns:
- `@lru_cache()` decorator for singleton factory functions
- `get_*` naming convention for factory functions
- `Depends()` for injecting dependencies into route handlers
- Constructor injection in service classes

### 5. Documented Configuration Pattern with pydantic-settings

**Settings Class** (`ARCHITECTURE.md:759-774`):
```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Database
    database_type: str = "bigquery"
    bigquery_project_id: str
    bigquery_dataset_id: str

    # API
    api_title: str = "Analytics Dashboard API"
    api_version: str = "1.0.0"

    class Config:
        env_file = ".env"

settings = Settings()
```

Key patterns:
- Inherits from `pydantic_settings.BaseSettings`
- Type-annotated fields with defaults
- Inner `Config` class specifying `.env` file
- Module-level `settings` singleton instance

### 6. Documented Service Layer Pattern

**AnalyticsService** (`ARCHITECTURE.md:138-163`):
```python
class AnalyticsService:
    def __init__(self, db_client: DatabaseClient):
        self._db = db_client

    async def execute_analytics_query(
        self,
        table: str,
        request: AnalyticsRequest
    ) -> AnalyticsResult:
        query = QueryBuilder(table)
        if request.filters:
            query = self._apply_filters(query, request.filters)
        if request.aggregations:
            query = self._apply_aggregations(query, request.aggregations)
        query_def = query.build()
        results = await self._db.execute_query(query_def)
        return AnalyticsResult(data=results)
```

### 7. Documented Database Abstraction Pattern

**Protocol-based Interface** (`ARCHITECTURE.md:387-410`):
```python
from typing import Protocol, List, Dict, Any

class DatabaseClient(Protocol):
    async def execute_query(self, query: QueryDefinition) -> List[Dict[str, Any]]:
        ...

    async def health_check(self) -> bool:
        ...
```

### 8. Application Start Expectations

Based on `pyproject.toml:17-18`:
1. Running `commerce-intelligence` CLI command invokes `commerce_intelligence.main()`
2. Currently, this prints "Hello from commerce-intelligence!" and exits
3. The intended behavior (from architecture docs) is to start a FastAPI server via Uvicorn

The architecture documents do not show an explicit `create_app()` factory pattern. The expected flow is:
- `main()` initializes and runs the FastAPI application
- Uvicorn serves the app (as indicated by the `uvicorn>=0.40.0` dependency)

#### Testing patterns
- No tests currently exist in the codebase
- ARCHITECTURE.md documents a testing strategy (`ARCHITECTURE.md:886-917`) with:
  - Unit tests for QueryBuilder (no database needed)
  - Unit tests for QueryTranslator (no database needed)
  - Service tests with mock DatabaseClient

## Code References

- `src/commerce_intelligence/__init__.py:1-2` - Current main entry point with placeholder function
- `pyproject.toml:17-18` - Script entry point configuration
- `pyproject.toml:10-15` - Project dependencies (FastAPI, Pydantic, pydantic-settings, Uvicorn)
- `ARCHITECTURE.md:697-751` - Intended directory structure
- `ARCHITECTURE.md:759-774` - Settings configuration pattern
- `ARCHITECTURE.md:783-799` - Dependency injection factory pattern
- `ARCHITECTURE.md:110-120` - Endpoint dependency injection usage
- `ARCHITECTURE.md:138-163` - Service layer pattern
- `ARCHITECTURE.md:387-410` - Database client protocol

## Architecture Documentation

Two architecture documents exist:

1. **ARCHITECTURE.md** - Primary architecture document with:
   - Layered architecture diagram
   - Builder pattern for query construction
   - Composite/Visitor pattern for filters
   - Strategy pattern for database translation
   - Full code examples for all components

2. **ARCHITECTURE_REVISED.md** - Simplified variant emphasizing:
   - Row-level security with mandatory tenant filtering
   - Simplified dataclass-based approach
   - Bracket notation for query parameters (e.g., `status[eq]=active`)
   - Schema registry for table validation

Both documents describe similar overall structure but differ in filter representation and security emphasis.

## Open Questions

1. How does the intended `main.py` / `main()` function initialize the FastAPI application and register routers?
2. Does ARCHITECTURE_REVISED.md represent an evolution or alternative to ARCHITECTURE.md?
